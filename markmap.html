<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.4/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.15.4/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.4/dist/index.js"></script><script>(e=>{window.WebFontConfig={custom:{families:["KaTeX_AMS","KaTeX_Caligraphic:n4,n7","KaTeX_Fraktur:n4,n7","KaTeX_Main:n4,n7,i4,i7","KaTeX_Math:i4,i7","KaTeX_Script","KaTeX_SansSerif:n4,n7,i4","KaTeX_Size1","KaTeX_Size2","KaTeX_Size3","KaTeX_Size4","KaTeX_Typewriter"]},active:()=>{e().refreshHook.call()}}})(()=>window.markmap)</script><script src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" defer></script><script>(()=>{setTimeout(()=>{const{markmap:M,mm:ge}=window,me=new M.Toolbar;me.attach(ge);const fe=me.render();fe.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(fe)})})()</script><script>((F,I,R,H)=>{const X=F();window.mm=X.Markmap.create("svg#mindmap",(I||X.deriveOptions)(H),R)})(()=>window.markmap,null,{"type":"root","depth":0,"content":"","children":[{"type":"heading","depth":1,"payload":{"lines":[0,1]},"content":"内核_系统启动_System_Startup","children":[{"type":"heading","depth":2,"payload":{"lines":[2,3]},"content":"BIOS","children":[]},{"type":"heading","depth":2,"payload":{"lines":[4,5]},"content":"引导装入程序  The Boot Loader","children":[]},{"type":"heading","depth":2,"payload":{"lines":[6,7]},"content":"从磁盘启动 Linux Booting Linux from a disk","children":[]},{"type":"heading","depth":2,"payload":{"lines":[8,9]},"content":"setup()","children":[]},{"type":"heading","depth":2,"payload":{"lines":[10,11]},"content":"startup_32()","children":[]},{"type":"heading","depth":2,"payload":{"lines":[12,13]},"content":"start_kernel()","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[14,15]},"content":"内核_内存寻址_Memory_Addressing","children":[{"type":"heading","depth":2,"payload":{"lines":[16,17]},"content":"内存地址 Memory Addresses","children":[{"type":"heading","depth":3,"payload":{"lines":[18,19]},"content":"逻辑地址 Logical addresses","children":[]},{"type":"heading","depth":3,"payload":{"lines":[20,21]},"content":"线性地址 Linear addresses","children":[]},{"type":"heading","depth":3,"payload":{"lines":[22,23]},"content":"物理地址 Physical addresses","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[24,25]},"content":"硬件中的分段 Segmentation in Hardware","children":[{"type":"heading","depth":3,"payload":{"lines":[26,27]},"content":"段选择器和段寄存器 Segment Selectors and Segmentation Registers","children":[{"type":"heading","depth":4,"payload":{"lines":[28,29]},"content":"段寄存器 Segmentation Registers","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[30,31]},"content":"段描述符 Segment Descriptors","children":[]},{"type":"heading","depth":3,"payload":{"lines":[32,33]},"content":"快速访问段描述符 Fast Access to Segment Descriptors","children":[{"type":"heading","depth":4,"payload":{"lines":[34,35]},"content":"非编程寄存器 Nonprogrammable Register","children":[]},{"type":"heading","depth":4,"payload":{"lines":[36,37]},"content":"段选择符字段 Segment Selector fields","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[38,39]},"content":"分段单元 Segmentation Unit","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[40,41]},"content":"系统中的分段 Segmentation in Linux","children":[{"type":"heading","depth":3,"payload":{"lines":[42,43]},"content":"The Linux GDT","children":[{"type":"heading","depth":4,"payload":{"lines":[44,45]},"content":"四个用户态和内核态下的代码段和数据段 Four user and kernel code and data segments","children":[]},{"type":"heading","depth":4,"payload":{"lines":[46,47]},"content":"一个任务状态段 A Task State Segment","children":[]},{"type":"heading","depth":4,"payload":{"lines":[48,49]},"content":"一个包含缺省局部描述符表的段 A segment including the default LDT","children":[]},{"type":"heading","depth":4,"payload":{"lines":[50,51]},"content":"三个局部线程存储段 Three Thread-Local Storage segments","children":[]},{"type":"heading","depth":4,"payload":{"lines":[52,53]},"content":"三个与高级电源管理（APM）相关的段 Three segments related to Advanced Power Management","children":[]},{"type":"heading","depth":4,"payload":{"lines":[54,55]},"content":"五个与即插即用（PnP）功能的BIOS服务程序相关的段 Five segments related to Plug and Play BIOS services.","children":[]},{"type":"heading","depth":4,"payload":{"lines":[56,57]},"content":"一个被内核用来处理“双重错误”异常的特殊TSS段 A special TSS segment used by the kernel to handle &quot;Double Fault&quot; exceptions","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[58,59]},"content":"The Linux LDTs","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[60,61]},"content":"硬件中的分页 Paging in Hardware","children":[{"type":"heading","depth":3,"payload":{"lines":[62,63]},"content":"常规分页 Regular Paging","children":[]},{"type":"heading","depth":3,"payload":{"lines":[64,65]},"content":"拓展分页 Extended Paging","children":[]},{"type":"heading","depth":3,"payload":{"lines":[66,67]},"content":"硬件保护方案 Hardware Protection Scheme","children":[]},{"type":"heading","depth":3,"payload":{"lines":[68,69]},"content":"常规分页举例 An Example of Regular Paging","children":[]},{"type":"heading","depth":3,"payload":{"lines":[70,71]},"content":"物理地址扩展（PAE）分页机制 The Physical Address Extension (PAE) Paging Machanism","children":[]},{"type":"heading","depth":3,"payload":{"lines":[72,73]},"content":"64位系统中的分页 Paging for 64-bit Architectures","children":[]},{"type":"heading","depth":3,"payload":{"lines":[74,75]},"content":"硬件高速缓存 Hardware Cache","children":[]},{"type":"heading","depth":3,"payload":{"lines":[76,77]},"content":"转换后援缓冲器（TLB）Translation Lookaside Buffer","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[78,79]},"content":"Linux中的分页 Paging in Linux","children":[{"type":"heading","depth":3,"payload":{"lines":[80,81]},"content":"线性地址字段 The Linear Address Fields","children":[]},{"type":"heading","depth":3,"payload":{"lines":[82,83]},"content":"页表处理 Page Table Handling","children":[]},{"type":"heading","depth":3,"payload":{"lines":[84,85]},"content":"物理内存布局 Physical Memory Layout","children":[]},{"type":"heading","depth":3,"payload":{"lines":[86,87]},"content":"进程页表 Process Page Tables","children":[]},{"type":"heading","depth":3,"payload":{"lines":[88,89]},"content":"内核页表 Kernel Page Tables","children":[{"type":"heading","depth":4,"payload":{"lines":[90,91]},"content":"临时内核页表 Provisional kernel Page Tables","children":[]},{"type":"heading","depth":4,"payload":{"lines":[92,93]},"content":"当RAM小于896MB时的最终内核页表 Final kernel Page Table when RAM size is less than 896MB","children":[]},{"type":"heading","depth":4,"payload":{"lines":[94,95]},"content":"当RAM大小在896MB和4096MB之间时的最终内核页表 Final kernel Page Table when RAM size is between 896MB and 4096MB","children":[]},{"type":"heading","depth":4,"payload":{"lines":[96,97]},"content":"当RAM大于4096MB时的最终内核页表 Final kernel Page Tabel when Ram size is more than 4096MB","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[98,99]},"content":"固定映射的线性地址 Fix-Mapped Linear Addresses","children":[]},{"type":"heading","depth":3,"payload":{"lines":[100,101]},"content":"处理硬件高速缓存和TLB Handling the Hardware Cache and the TLB","children":[{"type":"heading","depth":4,"payload":{"lines":[102,103]},"content":"处理硬件高速缓存 Handling the hardware cache","children":[]},{"type":"heading","depth":4,"payload":{"lines":[104,105]},"content":"处理TLB Handling the TLB","children":[]}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[106,107]},"content":"内核_进程_Processes","children":[{"type":"heading","depth":2,"payload":{"lines":[108,109]},"content":"进程、轻量级进程和线程 Processes,Lightweight Processes,and Threads","children":[]},{"type":"heading","depth":2,"payload":{"lines":[110,111]},"content":"进程描述符 Process Descriptor","children":[{"type":"heading","depth":3,"payload":{"lines":[112,113]},"content":"进程状态 Process State","children":[]},{"type":"heading","depth":3,"payload":{"lines":[114,115]},"content":"标识一个进程 Identifying a Process","children":[{"type":"heading","depth":4,"payload":{"lines":[116,117]},"content":"进程描述符处理 Process descriptors handling","children":[]},{"type":"heading","depth":4,"payload":{"lines":[118,119]},"content":"标识当前进程 Identifying the current process","children":[]},{"type":"heading","depth":4,"payload":{"lines":[120,121]},"content":"双向链表 Doubly linked lists","children":[]},{"type":"heading","depth":4,"payload":{"lines":[122,123]},"content":"进程链表 The process list","children":[]},{"type":"heading","depth":4,"payload":{"lines":[124,125]},"content":"TASK_RUNNING状态的进程链表 The lists of TASK_RUNNING Processes","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[126,127]},"content":"进程间的关系 Relationships Among Processes","children":[{"type":"heading","depth":4,"payload":{"lines":[128,129]},"content":"pidhash表及链表 The pidhash table and chained lists","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[130,131]},"content":"如何组织进程 How Processes Are Organized","children":[{"type":"heading","depth":4,"payload":{"lines":[132,133]},"content":"等待队列 Wait queues","children":[]},{"type":"heading","depth":4,"payload":{"lines":[134,135]},"content":"等待队列的操作 Handling wait queues","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[136,137]},"content":"进程资源限制 Process Resource Limits","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[138,139]},"content":"进程切换 Process Switch","children":[{"type":"heading","depth":3,"payload":{"lines":[140,141]},"content":"硬件上下文 Hardware Context","children":[]},{"type":"heading","depth":3,"payload":{"lines":[142,143]},"content":"任务状态栏 Task State Segment","children":[{"type":"heading","depth":4,"payload":{"lines":[144,145]},"content":"thread字段 The thread field","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[146,147]},"content":"执行进程切换 Performing the Process Switch","children":[{"type":"heading","depth":4,"payload":{"lines":[148,149]},"content":"switch_to宏 The switch_to macro","children":[]},{"type":"heading","depth":4,"payload":{"lines":[150,151]},"content":"__switch_to()函数 The __switch_to() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[152,153]},"content":"保存和加载FPU、MMX及XMM寄存器 Saving and Loading the FPU,MMX,and XMM Registers","children":[{"type":"heading","depth":4,"payload":{"lines":[154,155]},"content":"保存FPU寄存器 Saving the FPU registers","children":[]},{"type":"heading","depth":4,"payload":{"lines":[156,157]},"content":"装载FPU寄存器 Loading the FPU registers","children":[]},{"type":"heading","depth":4,"payload":{"lines":[158,159]},"content":"在内核态使用FPU、MMX和SSE/SSE2单元 Using the FPU,MMX,and SSE/SSE2 units in Kernel Mode","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[160,161]},"content":"创建进程 Creating Processes","children":[{"type":"heading","depth":3,"payload":{"lines":[162,163]},"content":"clone()、fork()及vfork()系统调用 The clone(),fork(),and vfork() System Calls","children":[{"type":"heading","depth":4,"payload":{"lines":[164,165]},"content":"do_fork()函数 The do_fork() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[166,167]},"content":"copy_process()函数 The copy_process() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[168,169]},"content":"内核线程 Kernel Threads","children":[{"type":"heading","depth":4,"payload":{"lines":[170,171]},"content":"创建一个内核线程 Creating a kernel thread","children":[]},{"type":"heading","depth":4,"payload":{"lines":[172,173]},"content":"进程0 Process 0","children":[]},{"type":"heading","depth":4,"payload":{"lines":[174,175]},"content":"进程1 Process 1","children":[]},{"type":"heading","depth":4,"payload":{"lines":[176,177]},"content":"其他内核线程 Other kernel threads","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[178,179]},"content":"撤销进程 Destroying Processes","children":[{"type":"heading","depth":3,"payload":{"lines":[180,181]},"content":"进程终止 Process Termination","children":[{"type":"heading","depth":4,"payload":{"lines":[182,183]},"content":"do_group_exit()函数 The do_group_exit() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[184,185]},"content":"do_exit()函数 The do_exit() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[186,187]},"content":"进程删除 Process Removal","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[188,189]},"content":"内核_中断和异常_Interrupts_and_Exceptions","children":[{"type":"heading","depth":2,"payload":{"lines":[190,191]},"content":"中断信号的作用 The Role of Interrupt Signals","children":[]},{"type":"heading","depth":2,"payload":{"lines":[192,193]},"content":"中断和异常 Interrupts and Exceptions","children":[{"type":"heading","depth":3,"payload":{"lines":[194,195]},"content":"IRQ和中断 IRQs and Interrupts","children":[{"type":"heading","depth":4,"payload":{"lines":[196,197]},"content":"高级可编程中断控制器 The Advanced Programmable Interrupt Controller (APIC)","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[198,199]},"content":"异常 Exceptions","children":[]},{"type":"heading","depth":3,"payload":{"lines":[200,201]},"content":"中断描述符表 Interrupt Descriptor Table (IDT)","children":[]},{"type":"heading","depth":3,"payload":{"lines":[202,203]},"content":"中断和异常的硬件处理 Hardware Handling of Interrupts and Exceptions","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[204,205]},"content":"中断和异常处理程序的嵌套执行 Nested Execution of Exception and Interrupt Handles","children":[]},{"type":"heading","depth":2,"payload":{"lines":[206,207]},"content":"初始化中断描述符表 Initiallizing the Interrupt Descriptor Table","children":[{"type":"heading","depth":3,"payload":{"lines":[208,209]},"content":"中断门、陷阱门及系统门 Interrupt,Trap, and System Gates","children":[]},{"type":"heading","depth":3,"payload":{"lines":[210,211]},"content":"IDT的初步初始化 Preliminary Initialization of the IDT","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[212,213]},"content":"异常处理 Exception Handling","children":[{"type":"heading","depth":3,"payload":{"lines":[214,215]},"content":"为异常处理程序保存寄存器的值 Saving the Registers for the Exception Handler","children":[]},{"type":"heading","depth":3,"payload":{"lines":[216,217]},"content":"进入和离开异常处理程序 Entering and Leaving the Exception Handler","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[218,219]},"content":"中断处理 Interrupt Handling","children":[{"type":"heading","depth":3,"payload":{"lines":[220,221]},"content":"I/O中断处理 I/O Interrupte Handling","children":[]},{"type":"heading","depth":3,"payload":{"lines":[222,223]},"content":"处理器间中断处理 Interprocessor Interrupt Handling","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[224,225]},"content":"软中断及tasklet Softirqs and Tasklets","children":[{"type":"heading","depth":3,"payload":{"lines":[226,227]},"content":"软中断 Softirqs","children":[]},{"type":"heading","depth":3,"payload":{"lines":[228,229]},"content":"Tasklets","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[230,231]},"content":"工作队列 Work Queues","children":[]},{"type":"heading","depth":2,"payload":{"lines":[232,233]},"content":"从中断和异常返回 Returning from Interrupts and Exceptions","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[234,235]},"content":"内核_内核同步_Kernel_Synchronization","children":[{"type":"heading","depth":2,"payload":{"lines":[236,237]},"content":"内核如何为不同的请求提供服务 How the Kernel Services Requests","children":[{"type":"heading","depth":3,"payload":{"lines":[238,239]},"content":"内核抢占 Kernel Preemption","children":[]},{"type":"heading","depth":3,"payload":{"lines":[240,241]},"content":"什么时候同步是必需的 When Synchronization Is Necessary","children":[]},{"type":"heading","depth":3,"payload":{"lines":[242,243]},"content":"什么时候同步是不必要的 When Synchronization Is Not Necessary","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[244,245]},"content":"同步原语 Synchronization Primitives","children":[{"type":"heading","depth":3,"payload":{"lines":[246,247]},"content":"每CPU变量 Per-CPU Variables","children":[]},{"type":"heading","depth":3,"payload":{"lines":[248,249]},"content":"原子操作 Atomic Operations","children":[]},{"type":"heading","depth":3,"payload":{"lines":[250,251]},"content":"优化和内存屏障 Optimization and Memory Barriers","children":[]},{"type":"heading","depth":3,"payload":{"lines":[252,253]},"content":"自旋锁 Spin Locks","children":[{"type":"heading","depth":4,"payload":{"lines":[254,255]},"content":"具有内核抢占的spin_lock宏 The spin_lock macro with Kernel Preemption","children":[]},{"type":"heading","depth":4,"payload":{"lines":[256,257]},"content":"非抢占式内核中的spin_lock宏 The spin_lock macro without Kernel Preemption","children":[]},{"type":"heading","depth":4,"payload":{"lines":[258,259]},"content":"spin_unlock宏 The spin_unlock macro","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[260,261]},"content":"读/写自旋锁 Read/White Spin Locks","children":[{"type":"heading","depth":4,"payload":{"lines":[262,263]},"content":"为读获取和释放一个锁 Getting and releasing a lock for reading","children":[]},{"type":"heading","depth":4,"payload":{"lines":[264,265]},"content":"为写获取和释放一个锁 Getting and releasing a lock for writing","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[266,267]},"content":"顺序锁 Seqlocks","children":[]},{"type":"heading","depth":3,"payload":{"lines":[268,269]},"content":"读-拷贝-更新（RCU）Read-Copy Update","children":[]},{"type":"heading","depth":3,"payload":{"lines":[270,271]},"content":"信号量 Semaphores","children":[{"type":"heading","depth":4,"payload":{"lines":[272,273]},"content":"获取和释放信号量 Getting and releasing semaphores","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[274,275]},"content":"读/写信号量 Read/Write Semaphores","children":[]},{"type":"heading","depth":3,"payload":{"lines":[276,277]},"content":"补充原语 Completions","children":[]},{"type":"heading","depth":3,"payload":{"lines":[278,279]},"content":"禁止本地中断 Local Interrupt Disabling","children":[]},{"type":"heading","depth":3,"payload":{"lines":[280,281]},"content":"禁止和激活可延迟函数 Disabling and Enabling Deferrable Functions","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[282,283]},"content":"对内核数据结构的同步访问 Synchronizing Accesses to Kernel Data Structures","children":[{"type":"heading","depth":3,"payload":{"lines":[284,285]},"content":"在自旋锁、信号量及中断禁止之间选择 Choosing Among Spin Locks,Semaphores,and Interrupt Disabling","children":[{"type":"heading","depth":4,"payload":{"lines":[286,287]},"content":"保护异常所访问的数据结构 Protecting a data structure accessed by exceptions","children":[]},{"type":"heading","depth":4,"payload":{"lines":[288,289]},"content":"保护中断所访问的数据结构 Protecting a data structure accessed by interrupts","children":[]},{"type":"heading","depth":4,"payload":{"lines":[290,291]},"content":"保护可延迟函数所访问的数据结构 Protecting a data structure accessed by deferrable functions","children":[]},{"type":"heading","depth":4,"payload":{"lines":[292,293]},"content":"保护由异常和中断访问的数据结构  Protecting a data structure accessed by exceptions and interrupts","children":[]},{"type":"heading","depth":4,"payload":{"lines":[294,295]},"content":"保护由异常和可延迟函数访问的数据结构  Protecting a data structure accessed by exceptions and deferrable functions","children":[]},{"type":"heading","depth":4,"payload":{"lines":[296,297]},"content":"保护由中断和可延迟函数访问的数据结构  Protecting a data structure accessed by interrupts and deferrable functions","children":[]},{"type":"heading","depth":4,"payload":{"lines":[298,299]},"content":"保护由异常、中断和可延迟函数访问的数据结构  Protecting a data structure accessed by exceptions, interrupts, and deferrable functions","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[300,301]},"content":"避免竞争条件的实例 Examples of Race Condition Prevention","children":[{"type":"heading","depth":3,"payload":{"lines":[302,303]},"content":"引用计数器 Reference Counters","children":[]},{"type":"heading","depth":3,"payload":{"lines":[304,305]},"content":"大内核锁 The Big Kernel Lock","children":[]},{"type":"heading","depth":3,"payload":{"lines":[306,307]},"content":"内存描述符读/写信号量 Memory Descriptor Read/Write Semaphore","children":[]},{"type":"heading","depth":3,"payload":{"lines":[308,309]},"content":"slab高速缓存链表的信号量 Slab Cache List Semaphore","children":[]},{"type":"heading","depth":3,"payload":{"lines":[310,311]},"content":"索引节点的信号量 Inode Semaphore","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[312,313]},"content":"内核_定时测量_Timing_Measurements","children":[{"type":"heading","depth":2,"payload":{"lines":[314,315]},"content":"时钟和定时器电路 Clock and Timer Circuits","children":[{"type":"heading","depth":3,"payload":{"lines":[316,317]},"content":"实时时钟 Real Time Clock (RTC)","children":[]},{"type":"heading","depth":3,"payload":{"lines":[318,319]},"content":"时间戳计数器 Time Stamp Counter (TSC)","children":[]},{"type":"heading","depth":3,"payload":{"lines":[320,321]},"content":"可编程间隔定时器 Programmable Interval Timer (PIT)","children":[]},{"type":"heading","depth":3,"payload":{"lines":[322,323]},"content":"CPU本地定时器 CPU Local Timer","children":[]},{"type":"heading","depth":3,"payload":{"lines":[324,325]},"content":"高精度事件定时器 High Precision Event Timer (HPET)","children":[]},{"type":"heading","depth":3,"payload":{"lines":[326,327]},"content":"ACPI电源管理定时器 ACPI Power Management Timer","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[328,329]},"content":"Linux计时体系结构 The Linux Timekeeping Architecture","children":[{"type":"heading","depth":3,"payload":{"lines":[330,331]},"content":"计时体系机构的数据结构 Data Structures of the Timekeeping Architecture","children":[{"type":"heading","depth":4,"payload":{"lines":[332,333]},"content":"定时器对象 The timer object","children":[]},{"type":"heading","depth":4,"payload":{"lines":[334,335]},"content":"jiffies变量 The jiffies variable","children":[]},{"type":"heading","depth":4,"payload":{"lines":[336,337]},"content":"xtime变量 The xtime variable","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[338,339]},"content":"单处理器系统上的计时体系结构 Timekeeping Architecture in Uniprocessor Systems","children":[{"type":"heading","depth":4,"payload":{"lines":[340,341]},"content":"初始化阶段 Initialization phase","children":[]},{"type":"heading","depth":4,"payload":{"lines":[342,343]},"content":"时钟中断处理程序 The timer interrupt handler","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[344,345]},"content":"多处理器系统上的计时体系结构 Timekeeping Architecture in Multiprocessor Systems","children":[{"type":"heading","depth":4,"payload":{"lines":[346,347]},"content":"初始化阶段 Initialization phase","children":[]},{"type":"heading","depth":4,"payload":{"lines":[348,349]},"content":"全局时钟中断处理程序 The global timer interrupt handler","children":[]},{"type":"heading","depth":4,"payload":{"lines":[350,351]},"content":"本地时钟中断处理程序 The local timer interrupt handler","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[352,353]},"content":"更新时间和日期 Updating the Time and Date","children":[]},{"type":"heading","depth":2,"payload":{"lines":[354,355]},"content":"更新系统统计数 Updating System Statistics","children":[{"type":"heading","depth":3,"payload":{"lines":[356,357]},"content":"更新本地CPU统计数 Updating Local CPU Statistics","children":[]},{"type":"heading","depth":3,"payload":{"lines":[358,359]},"content":"记录系统负载 Keeping Track of System Load","children":[]},{"type":"heading","depth":3,"payload":{"lines":[360,361]},"content":"监管内核代码 Profiling the Kernel Code","children":[]},{"type":"heading","depth":3,"payload":{"lines":[362,363]},"content":"检查非屏蔽中断（NMI）监视器 Checking the NMI Watchdogs","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[364,365]},"content":"软定时器和延迟函数 Software Timers and Delay Functions","children":[{"type":"heading","depth":3,"payload":{"lines":[366,367]},"content":"动态定时器 Dynamic Timers","children":[{"type":"heading","depth":4,"payload":{"lines":[368,369]},"content":"动态定时器与竞争条件 Dynamic timers and race conditions","children":[]},{"type":"heading","depth":4,"payload":{"lines":[370,371]},"content":"动态定时器的数据结构 Data structures for dynamic timers","children":[]},{"type":"heading","depth":4,"payload":{"lines":[372,373]},"content":"动态定时器处理 Dynamic timer handling","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[374,375]},"content":"动态定时器应用之一：nanosleep()系统调用 An Application of Dynamic Timers: the nanosleep() System Call","children":[]},{"type":"heading","depth":3,"payload":{"lines":[376,377]},"content":"延迟函数 Delay Functions","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[378,379]},"content":"与定时测量相关的系统调用 System Calls Related to Timing Measurements","children":[{"type":"heading","depth":3,"payload":{"lines":[380,381]},"content":"time()和gettimeofday()系统调用 The time() and gettimeofday() System Calls","children":[]},{"type":"heading","depth":3,"payload":{"lines":[382,383]},"content":"adjtimex()系统调用 The adjtimex() System Call","children":[]},{"type":"heading","depth":3,"payload":{"lines":[384,385]},"content":"setitimer()和alarm()系统调用 The setitimer() and alarm() System Calls","children":[]},{"type":"heading","depth":3,"payload":{"lines":[386,387]},"content":"与POSIX定时器相关的系统调用 System Calls for POSIX Timers","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[388,389]},"content":"内核_进程调度_Processes_Scheduling","children":[{"type":"heading","depth":2,"payload":{"lines":[390,391]},"content":"调度策略 Scheduling Policy","children":[{"type":"heading","depth":3,"payload":{"lines":[392,393]},"content":"进程的抢占 Process Preemption","children":[]},{"type":"heading","depth":3,"payload":{"lines":[394,395]},"content":"一个时间片必须持续多长？How Long Must a Quantum Last?","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[396,397]},"content":"调度算法 The Scheduling Algorithm","children":[{"type":"heading","depth":3,"payload":{"lines":[398,399]},"content":"普通进程的调度 Scheduling of Conventional Processes","children":[{"type":"heading","depth":4,"payload":{"lines":[400,401]},"content":"基本时间片 Base time quantum","children":[]},{"type":"heading","depth":4,"payload":{"lines":[402,403]},"content":"动态优先级和平均睡眠时间 Dynamic priority and average sleep time","children":[]},{"type":"heading","depth":4,"payload":{"lines":[404,405]},"content":"活动和过期进程 Active and expired processes","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[406,407]},"content":"实时进程的调度 Scheduling of Real-Time Processes","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[408,409]},"content":"调度程序所使用的数据结构 Data Structures Used by the Scheduler","children":[{"type":"heading","depth":3,"payload":{"lines":[410,411]},"content":"数据结构runqueue The runqueue Data Structure","children":[]},{"type":"heading","depth":3,"payload":{"lines":[412,413]},"content":"进程描述符 Process Descriptor","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[414,415]},"content":"调度程序所使用的函数 Functions Used by the Scheduler","children":[{"type":"heading","depth":3,"payload":{"lines":[416,417]},"content":"scheduler_tick()","children":[{"type":"heading","depth":4,"payload":{"lines":[418,419]},"content":"更新实时进程的时间片 Updating the time slice of a real-time process","children":[]},{"type":"heading","depth":4,"payload":{"lines":[420,421]},"content":"更新普通进程的时间片 Updating the time slice of a conventional process","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[422,423]},"content":"try_to_wake_up()","children":[]},{"type":"heading","depth":3,"payload":{"lines":[424,425]},"content":"recale_task_prio()","children":[]},{"type":"heading","depth":3,"payload":{"lines":[426,427]},"content":"schedule()","children":[{"type":"heading","depth":4,"payload":{"lines":[428,429]},"content":"直接调用 Direct invocation","children":[]},{"type":"heading","depth":4,"payload":{"lines":[430,431]},"content":"延迟调用 Lazy invocation","children":[]},{"type":"heading","depth":4,"payload":{"lines":[432,433]},"content":"进程切换之前schedule()所执行的操作 Actions performed by schedule() before a process switch","children":[]},{"type":"heading","depth":4,"payload":{"lines":[434,435]},"content":"schedule()完成进程切换时所执行的操作 Actions performed by schedule() to make the process switch","children":[]},{"type":"heading","depth":4,"payload":{"lines":[436,437]},"content":"进程切换后schedule()所执行的操作 Actions performed by schedule() after a process switch","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[438,439]},"content":"多处理器系统中运行队列的平衡 Runqueue Balancing in Multiprocessor Systems","children":[{"type":"heading","depth":3,"payload":{"lines":[440,441]},"content":"调度域 Scheduling Domains","children":[]},{"type":"heading","depth":3,"payload":{"lines":[442,443]},"content":"rebalance_tick()","children":[]},{"type":"heading","depth":3,"payload":{"lines":[444,445]},"content":"load_balance()","children":[]},{"type":"heading","depth":3,"payload":{"lines":[446,447]},"content":"move_tasks()","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[448,449]},"content":"与调度相关的系统调用 System Calls Related to Scheduling","children":[{"type":"heading","depth":3,"payload":{"lines":[450,451]},"content":"nice()系统调用","children":[]},{"type":"heading","depth":3,"payload":{"lines":[452,453]},"content":"getpriority()和setpriority()系统调用","children":[]},{"type":"heading","depth":3,"payload":{"lines":[454,455]},"content":"sched_getaffinity()和sched_setaffinity()系统调用","children":[]},{"type":"heading","depth":3,"payload":{"lines":[456,457]},"content":"与实时进程相关的系统调用 System Calls Related to Real-Time Processes","children":[{"type":"heading","depth":4,"payload":{"lines":[458,459]},"content":"sched_getscheduler()和sched_setschduler()系统调用","children":[]},{"type":"heading","depth":4,"payload":{"lines":[460,461]},"content":"sched_getparam()和shced_setparam()系统调用","children":[]},{"type":"heading","depth":4,"payload":{"lines":[462,463]},"content":"sched_yield()系统调用","children":[]},{"type":"heading","depth":4,"payload":{"lines":[464,465]},"content":"sched_get_priority_min()和sched_get_priority_max()系统调用","children":[]},{"type":"heading","depth":4,"payload":{"lines":[466,467]},"content":"sched_rr_get_interval()系统调用","children":[]}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[468,469]},"content":"内核_内存管理_Memory_Management","children":[{"type":"heading","depth":2,"payload":{"lines":[470,471]},"content":"页框管理 Page Frame Management","children":[{"type":"heading","depth":3,"payload":{"lines":[472,473]},"content":"页描述符 Page Descriptors","children":[]},{"type":"heading","depth":3,"payload":{"lines":[474,475]},"content":"非一致内存访问 Non-Uniform Memory Access (NUMA)","children":[]},{"type":"heading","depth":3,"payload":{"lines":[476,477]},"content":"内存管理区 Memory Zones","children":[]},{"type":"heading","depth":3,"payload":{"lines":[478,479]},"content":"保留的页框池 The Pool of Reserved Page Frames","children":[]},{"type":"heading","depth":3,"payload":{"lines":[480,481]},"content":"分区页框分配器 The Zoned Page Frame Allocator","children":[{"type":"heading","depth":4,"payload":{"lines":[482,483]},"content":"请求和释放页框 Requesting and releasing page frames","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[484,485]},"content":"高端内存页框的内核映射 Kernel Mappings of High-Memory Page Frames","children":[{"type":"heading","depth":4,"payload":{"lines":[486,487]},"content":"永久内核映射 Permanent kernel mappings","children":[]},{"type":"heading","depth":4,"payload":{"lines":[488,489]},"content":"临时内核映射 Temporary kernel mappings","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[490,491]},"content":"伙伴系统算法 The Buddy System Algorithm","children":[{"type":"heading","depth":4,"payload":{"lines":[492,493]},"content":"数据结构 Data structures","children":[]},{"type":"heading","depth":4,"payload":{"lines":[494,495]},"content":"分配块 Allocating a block","children":[]},{"type":"heading","depth":4,"payload":{"lines":[496,497]},"content":"释放块 Freeing a block","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[498,499]},"content":"每CPU页框高速缓存 The Per-CPU Page Frame Cache","children":[{"type":"heading","depth":4,"payload":{"lines":[500,501]},"content":"通过每CPU页框高速缓存分配页框 Allocating page frames through the per-CPU page frame caches","children":[]},{"type":"heading","depth":4,"payload":{"lines":[502,503]},"content":"释放页框到每CPU页框高速缓存 Releasing page frames to the per-CPU page frame caches","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[504,505]},"content":"管理区分配器 The Zone Allocator","children":[{"type":"heading","depth":4,"payload":{"lines":[506,507]},"content":"释放一组页框 Releasing a group of page frames","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[508,509]},"content":"内存区管理 Memory Area Management","children":[{"type":"heading","depth":3,"payload":{"lines":[510,511]},"content":"slab分配器 The Slab Allocator","children":[]},{"type":"heading","depth":3,"payload":{"lines":[512,513]},"content":"高速缓存描述符 Cache Descriptor","children":[]},{"type":"heading","depth":3,"payload":{"lines":[514,515]},"content":"slab描述符 Slab Descriptor","children":[]},{"type":"heading","depth":3,"payload":{"lines":[516,517]},"content":"普通和专用高速缓存 General and Specific Caches","children":[]},{"type":"heading","depth":3,"payload":{"lines":[518,519]},"content":"slab分配器与分区页框分配器的接口 Interfacing the Slab Allocator with the Zoned Page Frame Allocator","children":[]},{"type":"heading","depth":3,"payload":{"lines":[520,521]},"content":"给高速缓存分配slab Allocator a Slab to a Cache","children":[]},{"type":"heading","depth":3,"payload":{"lines":[522,523]},"content":"从高速缓存中释放slab Releasing a Slab from a Cache","children":[]},{"type":"heading","depth":3,"payload":{"lines":[524,525]},"content":"对象描述符 Object Descriptor","children":[]},{"type":"heading","depth":3,"payload":{"lines":[526,527]},"content":"对齐内存中的对象 Aligning Objects in Memory","children":[]},{"type":"heading","depth":3,"payload":{"lines":[528,529]},"content":"slab着色 Slab coloring","children":[]},{"type":"heading","depth":3,"payload":{"lines":[530,531]},"content":"空闲slab对象的本地高速缓存 Local Caches of Free Slab Objects","children":[]},{"type":"heading","depth":3,"payload":{"lines":[532,533]},"content":"分配slab对象 Allocating a Slab Object","children":[]},{"type":"heading","depth":3,"payload":{"lines":[534,535]},"content":"释放slab对象 Freeing a Slab Object","children":[]},{"type":"heading","depth":3,"payload":{"lines":[536,537]},"content":"通用对象 General Purpose Objects","children":[]},{"type":"heading","depth":3,"payload":{"lines":[538,539]},"content":"内存池 Memory Pools","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[540,541]},"content":"非连续内存区管理 Noncontiguous Memory Area Management","children":[{"type":"heading","depth":3,"payload":{"lines":[542,543]},"content":"非连续内存区的线性地址 Linear Addresses of Noncontiguous Memory Areas","children":[]},{"type":"heading","depth":3,"payload":{"lines":[544,545]},"content":"非连续内存区的描述符 Descriptors of Noncontiguous Memory Areas","children":[]},{"type":"heading","depth":3,"payload":{"lines":[546,547]},"content":"分配非连续内存区 Allocating a Noncontiguous Memory Area","children":[]},{"type":"heading","depth":3,"payload":{"lines":[548,549]},"content":"释放非连续内存区 Releasing a Noncontiguous Memory Area","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[550,551]},"content":"内核_进程地址空间_Process_Address_Space","children":[{"type":"heading","depth":2,"payload":{"lines":[552,553]},"content":"进程的地址空间 The Process`s Address Space","children":[]},{"type":"heading","depth":2,"payload":{"lines":[554,555]},"content":"内存描述符 The Memory Descriptor","children":[{"type":"heading","depth":3,"payload":{"lines":[556,557]},"content":"内核线程的内存描述符 Memory Descriptor of Kernel Threads","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[558,559]},"content":"线性区 Memory Regions","children":[{"type":"heading","depth":3,"payload":{"lines":[560,561]},"content":"线性区数据结构 Memory Region Data Structures","children":[]},{"type":"heading","depth":3,"payload":{"lines":[562,563]},"content":"线性区访问权限 Memory Region Access Rights","children":[]},{"type":"heading","depth":3,"payload":{"lines":[564,565]},"content":"线性区的处理 Memory Region Handling","children":[{"type":"heading","depth":4,"payload":{"lines":[566,567]},"content":"查找给定地址的最邻近区 Finding the closed region to a given address: find_vma()","children":[]},{"type":"heading","depth":4,"payload":{"lines":[568,569]},"content":"查找一个与给定的地址区间相重叠的线性区 Finding a region that overlaps a given interval: find_vma_intersection()","children":[]},{"type":"heading","depth":4,"payload":{"lines":[570,571]},"content":"查找一个空闲的地址空间 Finding a free interval: get_unmapped_area()","children":[]},{"type":"heading","depth":4,"payload":{"lines":[572,573]},"content":"向内存描述符链表中插入一个线性区 Inserting a region in the memory descriptor list: insert_vm_struct()","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[574,575]},"content":"分配线性地址区间 Allocating a Linear Address Interval","children":[]},{"type":"heading","depth":3,"payload":{"lines":[576,577]},"content":"释放线性地址区间 Releasing a Linear Address Interval","children":[{"type":"heading","depth":4,"payload":{"lines":[578,579]},"content":"The do_munmap() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[580,581]},"content":"The split_vma() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[582,583]},"content":"The unmap_region() function","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[584,585]},"content":"缺页异常处理程序 Page Fault Exception Handler","children":[{"type":"heading","depth":3,"payload":{"lines":[586,587]},"content":"处理地址空间外的错误地址 Handling a Faulty Address Outside the Address Space","children":[]},{"type":"heading","depth":3,"payload":{"lines":[588,589]},"content":"处理地址空间内的错误地址 Handling a Faulty Address Inside the Address Space","children":[]},{"type":"heading","depth":3,"payload":{"lines":[590,591]},"content":"请求调页 Demand Paging","children":[]},{"type":"heading","depth":3,"payload":{"lines":[592,593]},"content":"写时复制 Copy On Write","children":[]},{"type":"heading","depth":3,"payload":{"lines":[594,595]},"content":"处理非连续内存区访问 Handling Noncontiguous Memory Area Accesses","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[596,597]},"content":"创建和删除进程的地址空间 Creating and Deleting a Process Address Space","children":[{"type":"heading","depth":3,"payload":{"lines":[598,599]},"content":"创建进程的地址空间 Creating a Process Address Space","children":[]},{"type":"heading","depth":3,"payload":{"lines":[600,601]},"content":"删除进程的地址空间 Deleting a Process Address Space","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[602,603]},"content":"堆的管理 Managing the Heap","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[604,605]},"content":"内核_系统调用_System_Calls","children":[{"type":"heading","depth":2,"payload":{"lines":[606,607]},"content":"POSIX API 和系统调用 POSIX APIS and System Calls","children":[]},{"type":"heading","depth":2,"payload":{"lines":[608,609]},"content":"系统调用处理程序及服务例程 System Call Handler and Service Routines","children":[]},{"type":"heading","depth":2,"payload":{"lines":[610,611]},"content":"进入和退出系统调用 Entering and Exiting a System Call","children":[{"type":"heading","depth":3,"payload":{"lines":[612,613]},"content":"通过 ini <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mi>x</mi><mn>80</mn><mtext>指令发出系统调用</mtext><mi>I</mi><mi>s</mi><mi>s</mi><mi>u</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>a</mi><mi>S</mi><mi>y</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>C</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>v</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">0x80 指令发出系统调用 Issuing a System Call via the int</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">80</span><span class=\"mord cjk_fallback\">指令发出系统调用</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\">ss</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">ys</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">ia</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\">t</span></span></span></span>0x80 Instruction","children":[{"type":"heading","depth":4,"payload":{"lines":[614,615]},"content":"The system_call() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[616,617]},"content":"从系统调用退出 Exiting from the system call","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[618,619]},"content":"通过sysenter指令发出系统调用 Issuing a System Call via the sysenter Instruction","children":[{"type":"heading","depth":4,"payload":{"lines":[620,621]},"content":"sysenter指令 The sysenter instruction","children":[]},{"type":"heading","depth":4,"payload":{"lines":[622,623]},"content":"vsyscall页 The vsyscall page","children":[]},{"type":"heading","depth":4,"payload":{"lines":[624,625]},"content":"进入系统调用 Entering the system call","children":[]},{"type":"heading","depth":4,"payload":{"lines":[626,627]},"content":"退出系统调用 Exiting from the system call","children":[]},{"type":"heading","depth":4,"payload":{"lines":[628,629]},"content":"sysexit指令 The sysexit instruction","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[630,631]},"content":"The SYSENTER_RETURN code","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[632,633]},"content":"参数传递 Parameter Passing","children":[{"type":"heading","depth":3,"payload":{"lines":[634,635]},"content":"验证参数 Verifying the Parameters","children":[]},{"type":"heading","depth":3,"payload":{"lines":[636,637]},"content":"访问进程地址空间 Accessing the Process Address Space","children":[]},{"type":"heading","depth":3,"payload":{"lines":[638,639]},"content":"动态地址检查：修正代码 Dynamic Address Checking: The Fix-up Code","children":[]},{"type":"heading","depth":3,"payload":{"lines":[640,641]},"content":"异常表 The Exception Tables","children":[]},{"type":"heading","depth":3,"payload":{"lines":[642,643]},"content":"生成异常表和修正代码 Generating the Exception Tables and the Fixup Code","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[644,645]},"content":"内核封装例程 Kernel Warpper Routines","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[646,647]},"content":"内核_信号_Signals","children":[{"type":"heading","depth":2,"payload":{"lines":[648,649]},"content":"信号的作用 The Role of Signals","children":[{"type":"heading","depth":3,"payload":{"lines":[650,651]},"content":"传递信号前所执行的操作 Action Performed upon Delivering Signal","children":[]},{"type":"heading","depth":3,"payload":{"lines":[652,653]},"content":"POSIX信号和多线程应用 POSIX Signals and Multithreaded Applications","children":[]},{"type":"heading","depth":3,"payload":{"lines":[654,655]},"content":"与信号相关的数据结构 Data Structures Associated with Signals","children":[{"type":"heading","depth":4,"payload":{"lines":[656,657]},"content":"信号描述符和信号处理程序描述符 The signal descriptor and the signal handler descriptor","children":[]},{"type":"heading","depth":4,"payload":{"lines":[658,659]},"content":"sigaction 数据结构 The sigaction data structure","children":[]},{"type":"heading","depth":4,"payload":{"lines":[660,661]},"content":"挂起信号队列 The pending signal queues","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[662,663]},"content":"在信号数据结构上的操作 Operations on Signal Data Structures","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[664,665]},"content":"产生信号 Generating a Signal","children":[{"type":"heading","depth":3,"payload":{"lines":[666,667]},"content":"The specific_send_sig_info() Function","children":[]},{"type":"heading","depth":3,"payload":{"lines":[668,669]},"content":"The send_signal() Function","children":[]},{"type":"heading","depth":3,"payload":{"lines":[670,671]},"content":"The group_send_sig_info() Function","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[672,673]},"content":"传递信号 Delivering a Signal","children":[{"type":"heading","depth":3,"payload":{"lines":[674,675]},"content":"执行信号的缺省操作 Executing the Default Action for the Signal","children":[]},{"type":"heading","depth":3,"payload":{"lines":[676,677]},"content":"捕获信号 Catching the Signal","children":[{"type":"heading","depth":4,"payload":{"lines":[678,679]},"content":"建立帧 Setting up the frame","children":[]},{"type":"heading","depth":4,"payload":{"lines":[680,681]},"content":"检查信号标志 Evaluating the signal flags","children":[]},{"type":"heading","depth":4,"payload":{"lines":[682,683]},"content":"开始执行信号处理程序 Staring the signal handler","children":[]},{"type":"heading","depth":4,"payload":{"lines":[684,685]},"content":"终止信号处理程序 Terminating the signal handler","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[686,687]},"content":"系统调用的重新执行 Reexecution of System Calls","children":[{"type":"heading","depth":4,"payload":{"lines":[688,689]},"content":"重新执行被未捕获信号中断的系统调用 Restarting a system call interrupted by a non-caught signal","children":[]},{"type":"heading","depth":4,"payload":{"lines":[690,691]},"content":"为所捕获的信号重新执行系统调用 Restarting a system call for a caught signal","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[692,693]},"content":"与信号处理相关的系统调用 System Calls Related to Signal Handling","children":[{"type":"heading","depth":3,"payload":{"lines":[694,695]},"content":"The kill() System Call","children":[]},{"type":"heading","depth":3,"payload":{"lines":[696,697]},"content":"The tkill() and tgkill() System Calls","children":[]},{"type":"heading","depth":3,"payload":{"lines":[698,699]},"content":"改变信号的操作 Changing a Signal Action","children":[]},{"type":"heading","depth":3,"payload":{"lines":[700,701]},"content":"检查挂起的阻塞信号 Examining the Pending Blocked Signals","children":[]},{"type":"heading","depth":3,"payload":{"lines":[702,703]},"content":"修改阻塞信号的集合 Modifying the Set of Blocked Signals","children":[]},{"type":"heading","depth":3,"payload":{"lines":[704,705]},"content":"挂起进程 Suspending the Process","children":[]},{"type":"heading","depth":3,"payload":{"lines":[706,707]},"content":"实时信号的系统调用 System Calls for Real-Time Signals","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[708,709]},"content":"内核_虚拟文件系统_The_Virtual_Filesystem","children":[{"type":"heading","depth":2,"payload":{"lines":[710,711]},"content":"虚拟文件系统的作用 The Role of the Virtual Filesystem(VFS)","children":[{"type":"heading","depth":3,"payload":{"lines":[712,713]},"content":"通用文件模型 The Common File Model","children":[]},{"type":"heading","depth":3,"payload":{"lines":[714,715]},"content":"VFS所处理的系统调用 System Calls Handle by the VFS","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[716,717]},"content":"VFS的数据结构 VFS Data Structures","children":[{"type":"heading","depth":3,"payload":{"lines":[718,719]},"content":"超级块对象 Superblock Objects","children":[]},{"type":"heading","depth":3,"payload":{"lines":[720,721]},"content":"索引节点对象 Inode Objects","children":[]},{"type":"heading","depth":3,"payload":{"lines":[722,723]},"content":"文件对象 File Objects","children":[]},{"type":"heading","depth":3,"payload":{"lines":[724,725]},"content":"目录项对象 dentry Objects","children":[]},{"type":"heading","depth":3,"payload":{"lines":[726,727]},"content":"目录项高速缓存 The dentry Cache","children":[]},{"type":"heading","depth":3,"payload":{"lines":[728,729]},"content":"与进程相关的文件 Files associated with a Process","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[730,731]},"content":"文件系统类型 Filesystem Types","children":[{"type":"heading","depth":3,"payload":{"lines":[732,733]},"content":"特殊文件系统 Special Filesystems","children":[]},{"type":"heading","depth":3,"payload":{"lines":[734,735]},"content":"文件系统类型注册 Filesystem Type Registration","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[736,737]},"content":"文件系统处理 Filesystem Handling","children":[{"type":"heading","depth":3,"payload":{"lines":[738,739]},"content":"命名空间 Namespaces","children":[]},{"type":"heading","depth":3,"payload":{"lines":[740,741]},"content":"文件系统安装 Filesystem Mounting","children":[]},{"type":"heading","depth":3,"payload":{"lines":[742,743]},"content":"安装普通文件系统 Mounting a Generic Filesystem","children":[{"type":"heading","depth":4,"payload":{"lines":[744,745]},"content":"The do_kern_mount() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[746,747]},"content":"分配超级块对象 Allocating a superblock object","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[748,749]},"content":"安装根文件系统 Mounting the Root Filesystem","children":[{"type":"heading","depth":4,"payload":{"lines":[750,751]},"content":"安装rootfs文件系统 Mounting the rootfs filesystem","children":[]},{"type":"heading","depth":4,"payload":{"lines":[752,753]},"content":"安装实际根文件系统 Mounting the real root filesystem","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[754,755]},"content":"卸载文件系统 Unmounting a Filesystem","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[756,757]},"content":"路径名查找 Pathname Lookup","children":[{"type":"heading","depth":3,"payload":{"lines":[758,759]},"content":"标准路径名查找 Standard Pathname Lookup","children":[]},{"type":"heading","depth":3,"payload":{"lines":[760,761]},"content":"父路径名查找 Parent Pathname Lookup","children":[]},{"type":"heading","depth":3,"payload":{"lines":[762,763]},"content":"符号链接的查找 Lookup of Symbolic Links","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[764,765]},"content":"VFS系统调用的实现 Implementations of VFS System Calls","children":[{"type":"heading","depth":3,"payload":{"lines":[766,767]},"content":"The open() System Call","children":[]},{"type":"heading","depth":3,"payload":{"lines":[768,769]},"content":"The read() and write() System Calls","children":[]},{"type":"heading","depth":3,"payload":{"lines":[770,771]},"content":"The close() System Call","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[772,773]},"content":"文件加锁 File Locking","children":[{"type":"heading","depth":3,"payload":{"lines":[774,775]},"content":"Linux文件加锁 Linux File Locking","children":[]},{"type":"heading","depth":3,"payload":{"lines":[776,777]},"content":"文件锁的数据结构 File-Locking Data Structures","children":[]},{"type":"heading","depth":3,"payload":{"lines":[778,779]},"content":"FL_FLOCK Locks","children":[]},{"type":"heading","depth":3,"payload":{"lines":[780,781]},"content":"FL_POSIX Locks","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[782,783]},"content":"内核_I/O体系结构和设备驱动程序_I/O_Architecture_and_Device_Drivers","children":[{"type":"heading","depth":2,"payload":{"lines":[784,785]},"content":"I/O体系结构 I/O Architecture","children":[{"type":"heading","depth":3,"payload":{"lines":[786,787]},"content":"I/O端口 I/O Ports","children":[{"type":"heading","depth":4,"payload":{"lines":[788,789]},"content":"访问I/O端口 Accessing I/O ports","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[790,791]},"content":"I/O接口 I/O Interfaces","children":[{"type":"heading","depth":4,"payload":{"lines":[792,793]},"content":"专用I/O接口 Custom I/O interfaces","children":[]},{"type":"heading","depth":4,"payload":{"lines":[794,795]},"content":"通用I/O接口 General-purpose I/O interfaces","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[796,797]},"content":"设备控制器 Device Controllers","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[798,799]},"content":"设备驱动程序模型 The Device Driver Model","children":[{"type":"heading","depth":3,"payload":{"lines":[800,801]},"content":"sysfs文件系统 The sysfs Filesystem","children":[]},{"type":"heading","depth":3,"payload":{"lines":[802,803]},"content":"kobjects","children":[{"type":"heading","depth":4,"payload":{"lines":[804,805]},"content":"kobjects, ksets, and subsystems","children":[]},{"type":"heading","depth":4,"payload":{"lines":[806,807]},"content":"注册kobject、kset和subsystem Registering kobjects, ksets, and subsystems","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[808,809]},"content":"设备驱动程序模型的组件 Components of the Device Driver Model","children":[{"type":"heading","depth":4,"payload":{"lines":[810,811]},"content":"设备 Devices","children":[]},{"type":"heading","depth":4,"payload":{"lines":[812,813]},"content":"驱动程序 Drivers","children":[]},{"type":"heading","depth":4,"payload":{"lines":[814,815]},"content":"总线 Buses","children":[]},{"type":"heading","depth":4,"payload":{"lines":[816,817]},"content":"类 Classes","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[818,819]},"content":"设备文件 Device Files","children":[{"type":"heading","depth":3,"payload":{"lines":[820,821]},"content":"设备文件的用户态处理 User Mode Handling of Device Files","children":[{"type":"heading","depth":4,"payload":{"lines":[822,823]},"content":"动态分配设备号 Dynamic device number assignment","children":[]},{"type":"heading","depth":4,"payload":{"lines":[824,825]},"content":"动态创建设备文件 Dynamic device file creation","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[826,827]},"content":"设备文件的VFS处理 VFS Handling of Device Files","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[828,829]},"content":"设备驱动文件 Device Drivers","children":[{"type":"heading","depth":3,"payload":{"lines":[830,831]},"content":"注册设备驱动程序 Device Driver Registration","children":[]},{"type":"heading","depth":3,"payload":{"lines":[832,833]},"content":"初始化设备驱动程序 Device Driver Initialization","children":[]},{"type":"heading","depth":3,"payload":{"lines":[834,835]},"content":"监控I/O操作 Monitoring I/O Operations","children":[{"type":"heading","depth":4,"payload":{"lines":[836,837]},"content":"轮询模式 Polling mode","children":[]},{"type":"heading","depth":4,"payload":{"lines":[838,839]},"content":"中断模式 Interrupt mode","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[840,841]},"content":"访问I/O共享存储器 Accessing the I/O Shared Memory","children":[]},{"type":"heading","depth":3,"payload":{"lines":[842,843]},"content":"直接内存访问 Direct Memory Access (DMA)","children":[{"type":"heading","depth":4,"payload":{"lines":[844,845]},"content":"同步DMA和异步DMA Synchronous and asynchronous DMA","children":[]},{"type":"heading","depth":4,"payload":{"lines":[846,847]},"content":"DMA传送的辅助函数 Helper functions for DMA transfers","children":[]},{"type":"heading","depth":4,"payload":{"lines":[848,849]},"content":"总线地址 Bus addresses","children":[]},{"type":"heading","depth":4,"payload":{"lines":[850,851]},"content":"高速缓存的一致性 Cache coherency","children":[]},{"type":"heading","depth":4,"payload":{"lines":[852,853]},"content":"一致性DMA映射的辅助函数 Helper functions for coherent DMA mappings","children":[]},{"type":"heading","depth":4,"payload":{"lines":[854,855]},"content":"流式DMA映射的辅助函数 Helper functions for streaming DMA mappings","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[856,857]},"content":"内核支持的级别 Levels of Kernel Support","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[858,859]},"content":"字符设备驱动程序 Character Device Drivers","children":[{"type":"heading","depth":3,"payload":{"lines":[860,861]},"content":"分配设备号 Assigning Device Numbers","children":[{"type":"heading","depth":4,"payload":{"lines":[862,863]},"content":"The register_chrdev_region() and alloc_chrdev_region() functions","children":[]},{"type":"heading","depth":4,"payload":{"lines":[864,865]},"content":"The register_chrdev() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[866,867]},"content":"访问字符设备驱动程序 Accessing a Character Device Driver","children":[]},{"type":"heading","depth":3,"payload":{"lines":[868,869]},"content":"字符设备的缓冲策略 Buffering Strategies for Character Devices","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[870,871]},"content":"内核_块设备驱动程序_Block_Device_Drivers","children":[{"type":"heading","depth":2,"payload":{"lines":[872,873]},"content":"块设备的处理 Block Devices Handling","children":[{"type":"heading","depth":3,"payload":{"lines":[874,875]},"content":"扇区 Sectors","children":[]},{"type":"heading","depth":3,"payload":{"lines":[876,877]},"content":"块 Blocks","children":[]},{"type":"heading","depth":3,"payload":{"lines":[878,879]},"content":"段 Segments","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[880,881]},"content":"通用块层 The Generic Block Layer","children":[{"type":"heading","depth":3,"payload":{"lines":[882,883]},"content":"The Bio Structure","children":[]},{"type":"heading","depth":3,"payload":{"lines":[884,885]},"content":"磁盘和磁盘分区的表示 Representing Disks and Disk Partitions","children":[]},{"type":"heading","depth":3,"payload":{"lines":[886,887]},"content":"提交请求 Submitting a Request","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[888,889]},"content":"I/O调度程序 The I/O Scheduler","children":[{"type":"heading","depth":3,"payload":{"lines":[890,891]},"content":"请求队列描述符 Request Queue Descriptors","children":[]},{"type":"heading","depth":3,"payload":{"lines":[892,893]},"content":"请求描述符 Request Descriptors","children":[{"type":"heading","depth":4,"payload":{"lines":[894,895]},"content":"对请求描述符的分配进行管理 Managing the allocation of request descriptors","children":[]},{"type":"heading","depth":4,"payload":{"lines":[896,897]},"content":"避免请求队列拥塞 Avoiding request queue congestion","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[898,899]},"content":"激活块设备驱动程序 Activating the Block Device Driver","children":[]},{"type":"heading","depth":3,"payload":{"lines":[900,901]},"content":"I/O调度算法 I/O Scheduling Algorithms","children":[{"type":"heading","depth":4,"payload":{"lines":[902,903]},"content":"Noop 算法 The &quot;Noop&quot; elevator","children":[]},{"type":"heading","depth":4,"payload":{"lines":[904,905]},"content":"CFQ 算法 The &quot;CFQ&quot; elevator","children":[]},{"type":"heading","depth":4,"payload":{"lines":[906,907]},"content":"最后期限 算法 The &quot;Deadline&quot; elevator","children":[]},{"type":"heading","depth":4,"payload":{"lines":[908,909]},"content":"预期 算法 The &quot;Anticipatory&quot; elevator","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[910,911]},"content":"向 I/O 调度程序发出请求 Issuing a Request to the I/O Scheduler","children":[{"type":"heading","depth":4,"payload":{"lines":[912,913]},"content":"The blk_queue_bounce() function","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[914,915]},"content":"块设备驱动程序 Block Device Drivers","children":[{"type":"heading","depth":3,"payload":{"lines":[916,917]},"content":"块设备 Block Devices","children":[{"type":"heading","depth":4,"payload":{"lines":[918,919]},"content":"访问块设备 Accessing a block device","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[920,921]},"content":"注册和初始化设备驱动程序 Device Driver Registration and Initialization","children":[{"type":"heading","depth":4,"payload":{"lines":[922,923]},"content":"自定义驱动程序描述符 Defining a custom driver descriptor","children":[]},{"type":"heading","depth":4,"payload":{"lines":[924,925]},"content":"预定主设备号 Reserving the major number","children":[]},{"type":"heading","depth":4,"payload":{"lines":[926,927]},"content":"初始化自定义描述符 Initializing the custom descriptor","children":[]},{"type":"heading","depth":4,"payload":{"lines":[928,929]},"content":"初始化gendisk描述符 Initializing the gendisk descriptor","children":[]},{"type":"heading","depth":4,"payload":{"lines":[930,931]},"content":"初始化块设备操作表 Initializing the table of block device methods","children":[]},{"type":"heading","depth":4,"payload":{"lines":[932,933]},"content":"分配和初始化请求队列 Allocating and initializing a  request queue","children":[]},{"type":"heading","depth":4,"payload":{"lines":[934,935]},"content":"设置中断处理程序 Setting up the interrupt handler","children":[]},{"type":"heading","depth":4,"payload":{"lines":[936,937]},"content":"注册磁盘 Registering the disk","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[938,939]},"content":"策略例程 The Strategy Routine","children":[]},{"type":"heading","depth":3,"payload":{"lines":[940,941]},"content":"中断处理程序 The Interrupt Handler","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[942,943]},"content":"打开块设备文件 Opening a Block Device File","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[944,945]},"content":"内核_页高速缓存_The_Page_Cache","children":[{"type":"heading","depth":2,"payload":{"lines":[946,947]},"content":"页高速缓存 The Page Cache","children":[{"type":"heading","depth":3,"payload":{"lines":[948,949]},"content":"address_space对象 The address_space Object","children":[]},{"type":"heading","depth":3,"payload":{"lines":[950,951]},"content":"基树 The Radix Tree","children":[]},{"type":"heading","depth":3,"payload":{"lines":[952,953]},"content":"页高速缓存的处理函数 Page Cache Handling Functions","children":[{"type":"heading","depth":4,"payload":{"lines":[954,955]},"content":"查找页 Finding a page","children":[]},{"type":"heading","depth":4,"payload":{"lines":[956,957]},"content":"增加页 Adding a page","children":[]},{"type":"heading","depth":4,"payload":{"lines":[958,959]},"content":"删除页 Removing a page","children":[]},{"type":"heading","depth":4,"payload":{"lines":[960,961]},"content":"更新页 Updating a page","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[962,963]},"content":"基树的标记 The Tags of the Radix Tree","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[964,965]},"content":"把块存放在页高速缓存中 Storing Blocks in the Page Cache","children":[{"type":"heading","depth":3,"payload":{"lines":[966,967]},"content":"块缓冲区和缓冲区首部 Block Buffers and Buffer Heads","children":[]},{"type":"heading","depth":3,"payload":{"lines":[968,969]},"content":"管理缓冲区首部 Managing the Buffer Heads","children":[]},{"type":"heading","depth":3,"payload":{"lines":[970,971]},"content":"缓冲区页 Buffer Pages","children":[]},{"type":"heading","depth":3,"payload":{"lines":[972,973]},"content":"分配块设备缓冲区页 Allocating Block Device Buffer Pages","children":[]},{"type":"heading","depth":3,"payload":{"lines":[974,975]},"content":"释放块设备缓冲区页 Releasing Block Device BUffer Pages","children":[]},{"type":"heading","depth":3,"payload":{"lines":[976,977]},"content":"在页高速缓存中搜索块 Searching Blocks in the Page Cache","children":[{"type":"heading","depth":4,"payload":{"lines":[978,979]},"content":"The __find_get_block() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[980,981]},"content":"The __getblk() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[982,983]},"content":"The __bread() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[984,985]},"content":"向通用块层提交缓冲区首部 Submitting Buffer Heads to the Generic Block Layer","children":[{"type":"heading","depth":4,"payload":{"lines":[986,987]},"content":"The submit_bh() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[988,989]},"content":"The ll_rw_block() function","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[990,991]},"content":"把脏页写进磁盘 Writing Dirty Pages to Disk","children":[{"type":"heading","depth":3,"payload":{"lines":[992,993]},"content":"pdflush 内核线程 The pdflush Kernel Threads","children":[]},{"type":"heading","depth":3,"payload":{"lines":[994,995]},"content":"搜索要刷新的脏页 Looking for Dirty Pages To Be Flushed","children":[]},{"type":"heading","depth":3,"payload":{"lines":[996,997]},"content":"回写陈旧的脏页 Retrieving Old Dirty Pages","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[998,999]},"content":"sync(), fsync() and fdatasync()","children":[{"type":"heading","depth":3,"payload":{"lines":[1000,1001]},"content":"The sync() System Call","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1002,1003]},"content":"The fsync() and fdatasync() System Calls","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1004,1005]},"content":"内核_访问文件_Accessing_Files","children":[{"type":"heading","depth":2,"payload":{"lines":[1006,1007]},"content":"读写文件 Reading and Writing a File","children":[{"type":"heading","depth":3,"payload":{"lines":[1008,1009]},"content":"从文件中读取数据 Reading from a File","children":[{"type":"heading","depth":4,"payload":{"lines":[1010,1011]},"content":"普通文件的readpage方法 The readpage method for regular files","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1012,1013]},"content":"块设备文件的readpage方法 The readpage method for block device files","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1014,1015]},"content":"文件的预读 Read-Ahead of Files","children":[{"type":"heading","depth":4,"payload":{"lines":[1016,1017]},"content":"The page_cache_readahead() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1018,1019]},"content":"The handle_ra_miss() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1020,1021]},"content":"写入文件 Writing to a File","children":[{"type":"heading","depth":4,"payload":{"lines":[1022,1023]},"content":"普通文件的prepare_write和commit_write方法 The prepare_write and commit_write methods for regular files","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1024,1025]},"content":"块设备文件的prepare_write和commit_write方法 The prepare_write and commit_write methods for block device files","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1026,1027]},"content":"将脏页写到磁盘 Writing Dirty Pages to Disk","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1028,1029]},"content":"内存映射 Memory Mapping","children":[{"type":"heading","depth":3,"payload":{"lines":[1030,1031]},"content":"内存映射的数据结构 Memory Mapping Data Structures","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1032,1033]},"content":"创建内存映射 Creating a Memory Mapping","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1034,1035]},"content":"撤销内存映射 Destroying a Memory Mapping","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1036,1037]},"content":"内存映射的请求调页 Demand Paging for Memory Mapping","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1038,1039]},"content":"把内存映射的脏页刷新到磁盘 Flushing Dirty Memory Mapping Pages to Disk","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1040,1041]},"content":"非线性内存映射 Non-Linear Memory Mappings","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1042,1043]},"content":"直接I/O映射 Direct I/O Transfers","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1044,1045]},"content":"异步I/O Asynchronous I/O","children":[{"type":"heading","depth":3,"payload":{"lines":[1046,1047]},"content":"Linux 2.6 中的异步I/O Asynchronous I/O in Linux 2.6","children":[{"type":"heading","depth":4,"payload":{"lines":[1048,1049]},"content":"异步I/O环境 The asynchronous I/O context","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1050,1051]},"content":"提交异步I/O操作 Submitting the asynchronous I/O operations","children":[]}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1052,1053]},"content":"内核_回收页框_Page_Frame_Reclaiming","children":[{"type":"heading","depth":2,"payload":{"lines":[1054,1055]},"content":"页框回收算法 The Page Frame Reclaiming Algorithm","children":[{"type":"heading","depth":3,"payload":{"lines":[1056,1057]},"content":"选择目标页 Selecting a Target Page","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1058,1059]},"content":"PFRA设计 Design of the PFRA","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1060,1061]},"content":"反向映射 Reverse Mapping","children":[{"type":"heading","depth":3,"payload":{"lines":[1062,1063]},"content":"匿名页的反向映射 Reverse Mapping for Anonymous Pages","children":[{"type":"heading","depth":4,"payload":{"lines":[1064,1065]},"content":"The try_to_unmap_anon() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1066,1067]},"content":"The try_to_unmap_one() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1068,1069]},"content":"映射页的反向映射 Reverse Mapping for Mapped Pages","children":[{"type":"heading","depth":4,"payload":{"lines":[1070,1071]},"content":"优先搜索树 The priority search tree","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1072,1073]},"content":"The try_to_unmap_file() function","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1074,1075]},"content":"PFRA实现 Implementing the PFRA","children":[{"type":"heading","depth":3,"payload":{"lines":[1076,1077]},"content":"最近最少使用（LRU）链表 The Least Recently Used(LRU) Lists","children":[{"type":"heading","depth":4,"payload":{"lines":[1078,1079]},"content":"在LRU链表之间移动页  Moving pages across the LRU lists","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1080,1081]},"content":"The mark_page_accessed() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1082,1083]},"content":"The page_referenced() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1084,1085]},"content":"The refill_inactive_zone() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1086,1087]},"content":"内存紧缺回收 Low On Memory Reclaiming","children":[{"type":"heading","depth":4,"payload":{"lines":[1088,1089]},"content":"The free_more_memory() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1090,1091]},"content":"The try_to_free_pages() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1092,1093]},"content":"The shrink_caches() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1094,1095]},"content":"The shrink_zone() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1096,1097]},"content":"The shrink_cache() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1098,1099]},"content":"The shrink_list() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1100,1101]},"content":"The pageout() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1102,1103]},"content":"回收可压缩磁盘高速缓存的页 Reclaiming Pages of Shrinkable Disk Caches","children":[{"type":"heading","depth":4,"payload":{"lines":[1104,1105]},"content":"从目录项高速缓存回收页框 Reclaiming page frames from the dentry cache","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1106,1107]},"content":"从索引点高速缓存回收页框 Reclaiming page frames from the inode cache","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1108,1109]},"content":"周期回收 Periodic Reclaiming","children":[{"type":"heading","depth":4,"payload":{"lines":[1110,1111]},"content":"kswapd内核线程 The kswapd kernel threads","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1112,1113]},"content":"The cache_reap() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1114,1115]},"content":"内存不足删除程序 The Out of Memory Killer","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1116,1117]},"content":"交换标记 The Swap Token","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1118,1119]},"content":"交换 Swapping","children":[{"type":"heading","depth":3,"payload":{"lines":[1120,1121]},"content":"交换区 Swap Area","children":[{"type":"heading","depth":4,"payload":{"lines":[1122,1123]},"content":"创建和激活交换区 Creating and activating a swap area","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1124,1125]},"content":"如何在交换区中分布页 How to distribute pages in the swap areas","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1126,1127]},"content":"交换区描述符 Swap Area Descriptor","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1128,1129]},"content":"换出页标识符 Swapped-Out Page Identifier","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1130,1131]},"content":"激活和禁用交换区 Activating and Deactivating a Swap Area","children":[{"type":"heading","depth":4,"payload":{"lines":[1132,1133]},"content":"sys_swapon()服务例程 The sys_swapon() service routine","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1134,1135]},"content":"sys_swapoff()服务例程 The sys_swapoff() service routine","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1136,1137]},"content":"The try_to_unuse() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1138,1139]},"content":"分配和释放页槽 Allocating and Releasing a Page Slot","children":[{"type":"heading","depth":4,"payload":{"lines":[1140,1141]},"content":"The scan_swap_map() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1142,1143]},"content":"The get_swap_page() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1144,1145]},"content":"The swap_free() function","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1146,1147]},"content":"交换高速缓存 The Swap Cache","children":[{"type":"heading","depth":4,"payload":{"lines":[1148,1149]},"content":"交换高速缓存的实现 Swap cache implementation","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1150,1151]},"content":"交换高速缓存的辅助函数 Swap cache helper functions","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1152,1153]},"content":"换出页 Swapping Out Pages","children":[{"type":"heading","depth":4,"payload":{"lines":[1154,1155]},"content":"向交换高速缓存插入页框 Inserting the page frame in the swap cache","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1156,1157]},"content":"更新页表项  Updating the Page Table entries","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1158,1159]},"content":"将页写入交换区 Writing the page into the  swap area","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1160,1161]},"content":"从交换高速缓存中删除页框 Removing the page frame from the swap cache","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1162,1163]},"content":"换入页 Swapping in Pages","children":[{"type":"heading","depth":4,"payload":{"lines":[1164,1165]},"content":"The do_swap_page() function","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1166,1167]},"content":"The read_swap_cache_async() function","children":[]}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1168,1169]},"content":"内核_Ext2和Ext3文件系统_The_Ext2_and_Ext3_Filesystems","children":[{"type":"heading","depth":2,"payload":{"lines":[1170,1171]},"content":"Ext2的一般特征 General Characteristics of Ext2","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1172,1173]},"content":"Ext2磁盘数据结构 Ext2 Disk Data Structures","children":[{"type":"heading","depth":3,"payload":{"lines":[1174,1175]},"content":"超级块 Superblock","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1176,1177]},"content":"组描述符和位图 Group Descriptor and Bitmap","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1178,1179]},"content":"索引节点表 Inode Table","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1180,1181]},"content":"索引节点的增强属性 Extended Attributes of an Inode","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1182,1183]},"content":"访问控制列表 Access Control Lists","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1184,1185]},"content":"各种文件类型如何使用磁盘块 How Various File Types Use Disk Blocks","children":[{"type":"heading","depth":4,"payload":{"lines":[1186,1187]},"content":"普通文件 Regular file","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1188,1189]},"content":"目录 Directory","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1190,1191]},"content":"符号链接 Symbolic link","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1192,1193]},"content":"设备文件、管道和套接字 Device file, pipe and socket","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1194,1195]},"content":"Ext2的内存数据结构 Ext2 Memory Data Structures","children":[{"type":"heading","depth":3,"payload":{"lines":[1196,1197]},"content":"Ext2的超级块对象 Ext2 Superblock Object","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1198,1199]},"content":"Ext2的索引节点对象 Ext2 Inode Object","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1200,1201]},"content":"创建Ext2文件系统 Creating the Ext2 Filesystem","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1202,1203]},"content":"Ext2的方法 Ext2 Methods","children":[{"type":"heading","depth":3,"payload":{"lines":[1204,1205]},"content":"Ext2超级块的操作 Ext2 Superblock Operations","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1206,1207]},"content":"Ext2索引节点的操作 Ext2 Inode Operations","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1208,1209]},"content":"Ext2的文件操作 Ext2 File Operations","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1210,1211]},"content":"管理Ext2磁盘空间 Managing Ext2 Disk Space","children":[{"type":"heading","depth":3,"payload":{"lines":[1212,1213]},"content":"创建索引节点 Creating inodes","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1214,1215]},"content":"删除索引节点 Deleting inodes","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1216,1217]},"content":"数据块寻址 Data Blocks Addressing","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1218,1219]},"content":"文件的洞 File Holes","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1220,1221]},"content":"分配数据块 Allocating a Data Block","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1222,1223]},"content":"释放数据块 Releasing a Data Block","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1224,1225]},"content":"Ext3文件系统 The Ext3 Filesystem","children":[{"type":"heading","depth":3,"payload":{"lines":[1226,1227]},"content":"日志文件系统 Journaling Filesystems","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1228,1229]},"content":"Ext3日志文件系统 The Ext3 Journaling Filesystem","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1230,1231]},"content":"日志块设备层 The Journaling Block Device Layer","children":[{"type":"heading","depth":4,"payload":{"lines":[1232,1233]},"content":"日志记录 Log records","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1234,1235]},"content":"原子操作处理 Atomic operation handles","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1236,1237]},"content":"事务 Transactions","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1238,1239]},"content":"日志如何工作 How Journaling Works","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[1240,1241]},"content":"内核_进程通信_Process_Communication","children":[{"type":"heading","depth":2,"payload":{"lines":[1242,1243]},"content":"管道 Pipes","children":[{"type":"heading","depth":3,"payload":{"lines":[1244,1245]},"content":"使用管道 Using a Pipe","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1246,1247]},"content":"管道数据结构 Pipe Data Structures","children":[{"type":"heading","depth":4,"payload":{"lines":[1248,1249]},"content":"pipefs特殊文件系统 The pipefs special filesystem","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1250,1251]},"content":"创建和撤销管道 Creating and Destroying a Pipe","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1252,1253]},"content":"从管道中读取数据 Reading from Pipe","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1254,1255]},"content":"向管道中写入数据 Writing into a Pipe","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1256,1257]},"content":"FIFOs","children":[{"type":"heading","depth":3,"payload":{"lines":[1258,1259]},"content":"创建并打开FIFO Creating and Opening a FIFO","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1260,1261]},"content":"System V IPC","children":[{"type":"heading","depth":3,"payload":{"lines":[1262,1263]},"content":"使用IPC资源 Using an IPC Resource","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1264,1265]},"content":"ipc()系统调用 The ipc() System Call","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1266,1267]},"content":"IPC信号量 IPC Semaphores","children":[{"type":"heading","depth":4,"payload":{"lines":[1268,1269]},"content":"可取消的信号量操作 Undoable semaphore operations","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1270,1271]},"content":"挂起请求的队列 The queue of pending requests","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1272,1273]},"content":"IPC消息 IPC Messages","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1274,1275]},"content":"IPC共享内存 IPC Shared Memory","children":[{"type":"heading","depth":4,"payload":{"lines":[1276,1277]},"content":"换出IPC共享内存区的页 Swapping out pages of IPC shared memory regions","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1278,1279]},"content":"IPC共享内存区的请求调页 Demand paging for IPC shared memory regions","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[1280,1281]},"content":"POSIX消息队列 POSIX Message Queues","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[1282,1283]},"content":"内核_程序的执行_Program_Execution","children":[{"type":"heading","depth":2,"payload":{"lines":[1284,1285]},"content":"可执行文件 Executable Files","children":[{"type":"heading","depth":3,"payload":{"lines":[1286,1287]},"content":"进程的信任状核权能 Process Credentials and Capabilities","children":[{"type":"heading","depth":4,"payload":{"lines":[1288,1289]},"content":"进程的权能 Process capabilities","children":[]},{"type":"heading","depth":4,"payload":{"lines":[1290,1291]},"content":"Linux安全模块框架 The Linux Security Modules framework","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1292,1293]},"content":"命令行参数和shell环境 Command-Line Arguments and Shell Enviroment","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1294,1295]},"content":"库 Libraris","children":[]},{"type":"heading","depth":3,"payload":{"lines":[1296,1297]},"content":"程序段和进程的线性区 Program Segments and Process Memory Regions","children":[{"type":"heading","depth":4,"payload":{"lines":[1298,1299]},"content":"灵活线性区布局 Flexible memory region layout","children":[]}]},{"type":"heading","depth":3,"payload":{"lines":[1300,1301]},"content":"执行跟踪 Execution Tracing","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[1302,1303]},"content":"可执行格式 Executable Formats","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1304,1305]},"content":"执行域 Execution Domains","children":[]},{"type":"heading","depth":2,"payload":{"lines":[1306,1307]},"content":"exec函数 The exec Functions","children":[]}]}],"payload":{}},null)</script>
</body>
</html>
