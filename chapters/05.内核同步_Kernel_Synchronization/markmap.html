<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.4/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.15.4/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.4/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:M,mm:ge}=window,me=new M.Toolbar;me.attach(ge);const fe=me.render();fe.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(fe)})})()</script><script>((F,I,R,H)=>{const X=F();window.mm=X.Markmap.create("svg#mindmap",(I||X.deriveOptions)(H),R)})(()=>window.markmap,null,{"type":"heading","depth":0,"payload":{"lines":[0,1]},"content":"内核_内核同步_Kernel_Synchronization","children":[{"type":"heading","depth":1,"payload":{"lines":[2,3]},"content":"内核如何为不同的请求提供服务 How the Kernel Services Requests","children":[{"type":"heading","depth":2,"payload":{"lines":[4,5]},"content":"内核抢占 Kernel Preemption","children":[]},{"type":"heading","depth":2,"payload":{"lines":[6,7]},"content":"什么时候同步是必需的 When Synchronization Is Necessary","children":[]},{"type":"heading","depth":2,"payload":{"lines":[8,9]},"content":"什么时候同步是不必要的 When Synchronization Is Not Necessary","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[10,11]},"content":"同步原语 Synchronization Primitives","children":[{"type":"heading","depth":2,"payload":{"lines":[12,13]},"content":"每CPU变量 Per-CPU Variables","children":[]},{"type":"heading","depth":2,"payload":{"lines":[14,15]},"content":"原子操作 Atomic Operations","children":[]},{"type":"heading","depth":2,"payload":{"lines":[16,17]},"content":"优化和内存屏障 Optimization and Memory Barriers","children":[]},{"type":"heading","depth":2,"payload":{"lines":[18,19]},"content":"自旋锁 Spin Locks","children":[{"type":"heading","depth":3,"payload":{"lines":[20,21]},"content":"具有内核抢占的spin_lock宏 The spin_lock macro with Kernel Preemption","children":[]},{"type":"heading","depth":3,"payload":{"lines":[22,23]},"content":"非抢占式内核中的spin_lock宏 The spin_lock macro without Kernel Preemption","children":[]},{"type":"heading","depth":3,"payload":{"lines":[24,25]},"content":"spin_unlock宏 The spin_unlock macro","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[26,27]},"content":"读/写自旋锁 Read/White Spin Locks","children":[{"type":"heading","depth":3,"payload":{"lines":[28,29]},"content":"为读获取和释放一个锁 Getting and releasing a lock for reading","children":[]},{"type":"heading","depth":3,"payload":{"lines":[30,31]},"content":"为写获取和释放一个锁 Getting and releasing a lock for writing","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[32,33]},"content":"顺序锁 Seqlocks","children":[]},{"type":"heading","depth":2,"payload":{"lines":[34,35]},"content":"读-拷贝-更新（RCU）Read-Copy Update","children":[]},{"type":"heading","depth":2,"payload":{"lines":[36,37]},"content":"信号量 Semaphores","children":[{"type":"heading","depth":3,"payload":{"lines":[38,39]},"content":"获取和释放信号量 Getting and releasing semaphores","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[40,41]},"content":"读/写信号量 Read/Write Semaphores","children":[]},{"type":"heading","depth":2,"payload":{"lines":[42,43]},"content":"补充原语 Completions","children":[]},{"type":"heading","depth":2,"payload":{"lines":[44,45]},"content":"禁止本地中断 Local Interrupt Disabling","children":[]},{"type":"heading","depth":2,"payload":{"lines":[46,47]},"content":"禁止和激活可延迟函数 Disabling and Enabling Deferrable Functions","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[48,49]},"content":"对内核数据结构的同步访问 Synchronizing Accesses to Kernel Data Structures","children":[{"type":"heading","depth":2,"payload":{"lines":[50,51]},"content":"在自旋锁、信号量及中断禁止之间选择 Choosing Among Spin Locks,Semaphores,and Interrupt Disabling","children":[{"type":"heading","depth":3,"payload":{"lines":[52,53]},"content":"保护异常所访问的数据结构 Protecting a data structure accessed by exceptions","children":[]},{"type":"heading","depth":3,"payload":{"lines":[54,55]},"content":"保护中断所访问的数据结构 Protecting a data structure accessed by interrupts","children":[]},{"type":"heading","depth":3,"payload":{"lines":[56,57]},"content":"保护可延迟函数所访问的数据结构 Protecting a data structure accessed by deferrable functions","children":[]},{"type":"heading","depth":3,"payload":{"lines":[58,59]},"content":"保护由异常和中断访问的数据结构  Protecting a data structure accessed by exceptions and interrupts","children":[]},{"type":"heading","depth":3,"payload":{"lines":[60,61]},"content":"保护由异常和可延迟函数访问的数据结构  Protecting a data structure accessed by exceptions and deferrable functions","children":[]},{"type":"heading","depth":3,"payload":{"lines":[62,63]},"content":"保护由中断和可延迟函数访问的数据结构  Protecting a data structure accessed by interrupts and deferrable functions","children":[]},{"type":"heading","depth":3,"payload":{"lines":[64,65]},"content":"保护由异常、中断和可延迟函数访问的数据结构  Protecting a data structure accessed by exceptions, interrupts, and deferrable functions","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[66,67]},"content":"避免竞争条件的实例 Examples of Race Condition Prevention","children":[{"type":"heading","depth":2,"payload":{"lines":[68,69]},"content":"引用计数器 Reference Counters","children":[]},{"type":"heading","depth":2,"payload":{"lines":[70,71]},"content":"大内核锁 The Big Kernel Lock","children":[]},{"type":"heading","depth":2,"payload":{"lines":[72,73]},"content":"内存描述符读/写信号量 Memory Descriptor Read/Write Semaphore","children":[]},{"type":"heading","depth":2,"payload":{"lines":[74,75]},"content":"slab高速缓存链表的信号量 Slab Cache List Semaphore","children":[]},{"type":"heading","depth":2,"payload":{"lines":[76,77]},"content":"索引节点的信号量 Inode Semaphore","children":[]}]}]},null)</script>
</body>
</html>
